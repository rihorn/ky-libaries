// COPYRIGHT Â© 2018 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.10/esri/copyright.txt for details.

define(["require","exports"],function(e,n){return{background:{"background.frag":"uniform lowp vec4 u_color;\nvoid main() {\n  gl_FragColor = u_color;\n}\n","background.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\nvoid main() {\n  vec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n}\n"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\n\nvarying mediump vec2 v_uv;\n\nvoid main() {\n  lowp vec4 color = texture2D(u_tex, v_uv);\n\n  // Note: output in pre-multiplied alpha for correct alpha compositing\n  gl_FragColor = color *  u_opacity;\n}\n","bitBlit.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\n\nvarying mediump vec2 v_uv;\n\nvoid main(void) {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n  v_uv = a_tex;\n}\n"},highlight:{"blur.frag":"// A gaussian blur shader. It blurs the alpha channel of its input\n// according to 4 different sigma and stores the results into the\n// four channel of the target framebuffer.\n\n// It is intended to be called twice; the first time to perform an\n// horizontal blur, and a second time to perform a vertical blur.\n\n// This shader is used to turn the highlight mask into a highlight\n// map. The highlight map is an approximation of the signed distance\n// field of the mask.\n\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// Blur direction information. There are two possible\n// configurations that the host code can use.\n//  - [1, 0, 1/WIDTH, 0] Used when blurring horizontally. In this\n//    case u_direction[0] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[2] = 1/WIDTH is in texel units\n//    and is used to sample the right texel from the texture map.\n//  - [0, 1, 0, 1/HEIGHT] Used when blurring vertically. In this\n//    case u_direction[1] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[3] = 1/HEIGHT is in texel units\n//    and is used to sample the right texel from the texture map.\nuniform mediump vec4 u_direction;\n\n// Source to destination channel selection matrix.\nuniform mediump mat4 u_channelSelector;\n\n// The highlight map is obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// This is the highlight mask if we have not blurred horizontally yet, otherwise\n// it is the horizontally blurred highlight map and blurring it one more time\n// vertically will complete the process.\nuniform sampler2D u_texture;\n\n// The gaussian kernel. Note that it lacks the normalization constant, because\n// we want to store it unnormalized in the highlight map (i.e. having a peak\n// value of 1). Note also that we are using the SIMD (single instruction, multiple\n// data) capabilities of the GPU to compute four different gaussian kernels, one\n// for each sigma.\nmediump vec4 gauss(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas * u_sigmas));\n}\n\nmediump vec4 selectChannel(mediump vec4 sample) {\n  return u_channelSelector * sample;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight.\nvoid accumGauss(mediump float i, inout mediump vec4 tot, inout mediump vec4 weight) {\n  // Computes the gaussian weights, one for each sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump vec4 w = gauss(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw)) * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\nvoid main(void) {\n  // Initialize accumulated values and weights to zero.\n  mediump vec4 tot = vec4(0.0, 0.0, 0.0, 0.0);\n  mediump vec4 weight = vec4(0.0, 0.0, 0.0, 0.0);\n\n  // Accumulates enough samples. These will be taken\n  // horizontally or vertically depending on the value\n  // of u_direction.\n  accumGauss(-5.0, tot, weight);\n  accumGauss(-4.0, tot, weight);\n  accumGauss(-3.0, tot, weight);\n  accumGauss(-2.0, tot, weight);\n  accumGauss(-1.0, tot, weight);\n  accumGauss(0.0, tot, weight);\n  accumGauss(1.0, tot, weight);\n  accumGauss(2.0, tot, weight);\n  accumGauss(3.0, tot, weight);\n  accumGauss(4.0, tot, weight);\n  accumGauss(5.0, tot, weight);\n\n  // Compute blurred values.\n  mediump vec4 rgba = tot / weight;\n\n  // Return the values. Note that each channel will contain\n  // the result of a different blur operation, one for each\n  // of the four chosen sigma.\n  gl_FragColor = vec4(rgba);\n}\n","highlight.frag":"// Takes as input the highlight map, estimated the signed distance field,\n// and shades the fragments according to their estimated distance from the\n// edge of the highlighted feature.\n\n// A shade texture is used to turn distance values into colors; the shade\n// texture is basically a color gradient and is recomputed on the host\n// every time that the user alters the highlight options.\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// The highlight map. Each channel is a blurred\n// version of the alpha channel of the highlight mask.\n//  - Channel 0 (red) corresponds to a gaussian blur with sigma = u_sigmas[0];\n//  - Channel 1 (green) corresponds to a gaussian blur with sigma = u_sigmas[1];\n//  - Channel 2 (blue) corresponds to a gaussian blur with sigma = u_sigmas[2];\n//  - Channel 3 (alpha) corresponds to a gaussian blur with sigma = u_sigmas[3];\n// As of today, only channel 3 is used for distance estimation.\n// But the availability of different amounts of blur leaves the\n// door open to multi-scale approaches.\nuniform sampler2D u_texture;\n\n// The highlight map was obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// A 1-D texture used to shade the highlight.\nuniform sampler2D u_shade;\n\n// The 1-D shade texture is spreaded between u_minMaxDistance[0] and u_minMaxDistance[1].\nuniform mediump vec2 u_minMaxDistance;\n\n// Signed distance estimation.\nmediump float estimateDistance() {\n  // Use the largest sigma and the corresponding distance value stored in the\n  // last channel of the highlight map.\n  mediump float sigma = u_sigmas[3];\n  mediump float y = texture2D(u_texture, v_texcoord)[3];\n\n  // Estimates the distance by linearization and local inversion around\n  // the inflection point. The inflection point is in x = 0.\n  const mediump float y0 = 0.5;                           // Value of the convolution at the inflection point.\n  mediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * sigma);  // Slope of the convolution at the inflection point.\n  mediump float d = (y - y0) / m0;                        // Inversion of a local linearization.\n\n  // Return the estimated distance.\n  return d;\n}\n\n// Shading based on estimated distance.\nmediump vec4 shade(mediump float d) {\n  // Maps the sampled distance from the [A, D] range (see HighlightRenderer::setHighlightOptions) to [0, 1].\n  mediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\n\n  // Force to [0, 1]; it should not be necessary because the shade texture uses the CLAMP address mode, so\n  // this should happen anyway internally to the sampler, but in practice it is needed to avoid weird\n  // banding artifacts.\n  // We don't really know if we need this or not.\n  mappedDistance = clamp(mappedDistance, 0.0, 1.0);\n\n  // Sample the 1-D shade texture on its center line (i.e. on t=0.5).\n  return texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\n\nvoid main(void) {\n  // Estimate the distance.\n  mediump float d = estimateDistance();\n\n  // Shade the distance.\n  gl_FragColor = shade(d);\n}\n","textured.vert":"// Identity vertex shader that outputs an untransformed 2-D vertex\n// and passes its texture coordinates unchanged to the interpolator.\n\n// Vertex position.\nattribute mediump vec2 a_position;\n\n// Texture coordinates.\nattribute mediump vec2 a_texcoord;\n\n// Texture coordinates to be interpolated.\nvarying mediump vec2 v_texcoord;\n\nvoid main(void) {\n  // Pass the position unchanged.\n  gl_Position = vec4(a_position, 0.0, 1.0);\n\n  // Pass the texture coordinates unchanged.\n  v_texcoord = a_texcoord;\n}\n"},materials:{fill:{"fill.frag":"precision lowp float;\n\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\nvoid main()\n{\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_opacity * v_color * color;\n#else\n  gl_FragColor = v_opacity * v_color;\n#endif // PATTERN\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  //if (gl_FragColor.a < 1.0 / 255.0) {\n  //  discard;\n  //}\n  gl_FragColor = v_id;\n#endif // ID\n}\n","fill.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_id; // since we need to render the Id as a color we need to break it into RGBA components. so just like a color, the Id is normalized.\nattribute vec4 a_color;\nattribute vec4 a_tlbr;\nattribute vec4 a_aux1;\nattribute vec2 a_aux2;\n\nattribute float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n// T: TileCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_dvsMat3;\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/fill/vvUniforms.glsl>\n#include <materials/fill/vvFunctions.glsl>\n\n#ifdef PATTERN\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nconst float SIGNED_BYTE_TO_UNSIGNED = 128.0;\n\nvoid main()\n{\n#ifdef VV_OPACITY\n  v_opacity = getVVOpacity(a_vv.y);\n#else\n  v_opacity = 1.0;\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.x, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n\n#ifdef PATTERN\n  vec2 aux2 = (1.0 / SIGNED_BYTE_TO_UNSIGNED) * a_aux2;\n\n  // calculate the pattern matrix\n  mat3 patternMatrix = mat3(1.0, 0.0, 0.0,\n                            0.0, 1.0, 0.0,\n                            0.0, 0.0, 1.0);\n\n  patternMatrix[0][0] = 1.0 / (u_zoomFactor * a_aux1.x * aux2.x);\n  patternMatrix[1][1] = 1.0 / (u_zoomFactor * a_aux1.y * aux2.y);\n\n  vec2 symbolOffset = u_zoomFactor * (a_aux1.zw - vec2(SIGNED_BYTE_TO_UNSIGNED));\n\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from\n  // tile coordinates to texture coordinates.\n  v_tileTextureCoord = (patternMatrix * vec3(a_pos + symbolOffset, 1.0)).xy;\n  v_tlbr = vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\n#endif // PATTERN\n\n  float z = 2.0 * (1.0 - a_visible); // clip the vertex if the geometry isn't visible\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos, 1.);\n\n  gl_Position = vec4(v_pos.xy, z, 1.0);\n}\n","vvFunctions.glsl":"const highp float nanValue = 1e-30;\n\nbool isNan(float val) {\n  return (val == nanValue);\n  //return !(val < 0.0 || -1.0 < (val - 1.0) || val == 0.0);\n}\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\n\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR)|| defined(VV_OPACITY)\nattribute highp vec4 a_vv;\n#endif // VV_COLOR || VV_OPACITY\n\n#ifdef VV_COLOR\nuniform highp float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_OPACITY\nuniform highp float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n"},icon:{"icon.frag":"precision mediump float;\n\nuniform lowp sampler2D u_texture;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nconst float softEdgeRatio = 1.0; // use blur here if needed\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  float size = max(v_size.x, v_size.y);\n  float dist = d * size * softEdgeRatio;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (v_outlineWidth > 0.25) {\n    lowp vec4 outlinePixelColor = v_outlineColor;\n\n    // outlines can't be larger than the size of the symbol\n    float clampedOutlineSize = min(v_outlineWidth, size);\n\n    outlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\n\n    // finally combine the outline and the fill colors (outline draws on top of fill)\n    gl_FragColor = v_transparency * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n   lowp vec4 texColor = texture2D(u_texture, v_tex);\n   gl_FragColor = v_transparency * texColor;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"precision mediump float;\n\n//const float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst vec2 SIGNED_BYTE_TO_UNSIGNED = vec2(128.0);\n\n// per quad (instance) attributes (20 bytes ==> equivalent of 5 bytes per vertex)\nattribute vec2 a_pos;\nattribute vec4 a_vertexOffsetAndTex;\nattribute vec4 a_id; // since we need to render the Id as a color we need to break it into RGBA components. so just like a color, the Id is normalized.\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\n\nattribute float a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n// the of the icon given in pixels\nvarying mediump vec2 v_size;\n\n// icon color. If is a picture-marker it is used to tint the texture color\nvarying lowp vec4 v_color;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/icon/vvUniforms.glsl>\n#include <materials/icon/vvFunctions.glsl>\n\nvoid main()\n{\n  vec2 a_offset = a_vertexOffsetAndTex.xy;\n  vec2 a_tex = a_vertexOffsetAndTex.zw + SIGNED_BYTE_TO_UNSIGNED; // offset to change from signed to unsigned byte\n  vec2 a_size = a_sizeAndOutlineWidth.xy;\n\n  // default values (we need them for the variations to come)\n  float a_angle = 0.0;\n  float delta_z = 2.0 * (1.0 - a_visible);\n  float depth = 0.0;\n  v_transparency = 1.0;\n\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  // vv size override the original symbol's size\n  float h = getVVMinMaxSize(a_vv.x, a_size.y);\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\n  float h = u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\n  float h = getVVStopsSize(a_vv.x, a_size.y);\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\n  float h = getVVUnitValue(a_vv.x, a_size.y);\n#endif // VV_SIZE_UNIT_VALUE\n\n  // make sure to preserve the aspect ratio of the symbol\n  vec2 size = vec2(h * a_size.x / a_size.y, h);\n  vec3 offset = vec3(a_offset * size / a_size, 0.0);\n  v_size = size;\n#else\n  vec3 offset = vec3(a_offset, 0.0);\n  v_size = a_size;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef SDF\n  offset *= 2.0;\n#endif // SDF\n\n\n#ifdef VV_ROTATION\n  // If we have a rotation VV, we need to rotate our offset\n  offset = u_displayMat3 * getVVRotationMat3(a_vv.w) * offset;\n#else\n  offset = u_displayMat3 * offset;\n#endif // VV_ROTATION\n  vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + offset;\n\n  gl_Position = vec4(pos.xy, delta_z, 1.0);\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#else\n  v_transparency = 1.0;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n  // output the texture coordinates and the transparency\n  v_tex = a_tex / u_mosaicSize;\n\n#ifdef SDF\n  v_outlineColor = a_outlineColor;\n  // YF: in practice v_size.x and v_size.y are identical since we're mostly dealing with sms\n  v_outlineWidth = min(a_sizeAndOutlineWidth.z, max(v_size.x - 0.99, 0.0));\n#endif // SDF\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n}\n","vvFunctions.glsl":"const highp float nanValue = 1e-30;\n\nbool isNan(float val) {\n  return (val == nanValue);\n  //return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  interpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\n  return u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n\nmat3 getVVRotationMat3(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat3(1, 0, 0,\n                0, 1, 0,\n                0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * -rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat3(cosA, -sinA, 0,\n             sinA, cosA, 0,\n              0,    0,    1);\n}\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\nattribute highp vec4 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\n\n#ifdef VV_COLOR\nuniform highp float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform highp float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform highp float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n"},label:{"label.frag":"precision lowp float;\n\nuniform mediump sampler2D u_referenceTex;\nuniform mediump vec2 u_screenSize;\nuniform mediump float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\n\n#ifdef ID\nvarying mediump float v_fadeStep;\n#else\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_color;\n#endif // ID\n\nconst vec3 epsilon = vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\nvoid main()\n{\n  mediump vec2 refTextPos = gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\n  mediump vec4 referenceFragment = texture2D(u_referenceTex, refTextPos);\n#ifdef ID\n  mediump float alpha = clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\n  // fill the whole quad\n  gl_FragColor = vec4(alpha);\n#else\n  // read the fade alpha\n  lowp float fadeAlpha = referenceFragment.a;\n\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float sdfAlpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist);\n\n  gl_FragColor = fadeAlpha * sdfAlpha * v_color;\n#endif\n}\n","label.vert":"precision mediump float;\n\nattribute vec2 a_pos;                  // 2 * 2 (2 x signed 16)\nattribute vec4 a_color;                // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset;         // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texAndSize;          // 4 (4 x unsigned byte) texture coordinatesm and font size. w is for the halo size\nattribute vec4 a_refSymbolAndPlacementOffset; // 4 (4 x unsigned byte) the offset of the reference symbol of the feature (x,y) and the placement offset (z, w) all given in pixels\nattribute float a_vvSize;\n\nattribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\nattribute mediump vec2 a_visibilityRange; // 2 x unsigned byte;\n\n// T: TileCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\n\n\nuniform float u_mapRotation;\nuniform float u_mapAligned;\n\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\n// the curent zoom\nuniform mediump float u_zoomLevel; // the current zoom level X 10\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n\n#ifdef ID\nuniform mediump float u_fadeStep;\nvarying mediump float v_fadeStep;\n#else\nvarying mediump vec4 v_color;\n#endif // ID\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\n// by 16 and then at the shader devide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\nconst float outlineScale = 1.0 / 5.0;\nconst float sdfFontSize = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\n// 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\nconst float maxSdfDistance = 8.0;\n\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float PLACEMENT_PADDING = 8.0;\n\n#include <materials/icon/vvUniforms.glsl>\n#include <materials/icon/vvFunctions.glsl>\n\nvoid main()\n{\n  float refSymbolSize = a_refSymbolAndPlacementOffset.y;\n    \n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  #ifdef VV_SIZE_MIN_MAX_VALUE\n    // vv size override the original symbol's size\n    float h = getVVMinMaxSize(a_vvSize, refSymbolSize);\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_SCALE_STOPS\n    float h = u_vvSizeScaleStopsValue;\n  #endif // VV_SIZE_SCALE_STOPS\n\n  #ifdef VV_SIZE_FIELD_STOPS\n    float h = getVVStopsSize(a_vvSize, refSymbolSize);\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n    float h = getVVUnitValue(a_vvSize, refSymbolSize);\n  #endif // VV_SIZE_UNIT_VALUE\n    // make sure to preserve the aspect ratio of the symbol\n    float halfSize = h / 2.0;\n#else\n    float halfSize = refSymbolSize / 2.0;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  // make sure to clip the vertices in case that given record is marked as invisible\n  float z = 2.0 * (1.0 - a_visible);\n  float glyphAngle = a_refSymbolAndPlacementOffset.x * 360.0 / 254.0;\n  float mapAngle = u_mapRotation * 360.0 / 254.0;\n  float diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\n  \n  // make sure range is inclusive\n  z += 2.0 * (1.0 - step(a_visibilityRange.x, u_zoomLevel));\n  z += 2.0 * (1.0 - step(u_zoomLevel, a_visibilityRange.y));\n  z += 2.0 * u_mapAligned * step(90.0, diffAngle); \n\n  // encoded as dir + 1.0\n  vec2 placementDir = a_refSymbolAndPlacementOffset.zw - 1.0; \n  \n  // we use the list significant bit of the position in order to store the indication\n  // whether the vertex is of a halow of a glyph\n  mediump float halo = mod(a_pos, 2.0).x;\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n\n  float fontSize = a_texAndSize.z;\n  float fontScale = fontSize / sdfFontSize;\n\n  vec2 vertexOffset = offsetPrecision * a_vertexOffset;\n  vec2 placementOffset = placementDir * (halfSize + PLACEMENT_PADDING);\n  vec3 glyphOffset = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\n  vec3 v_pos = u_dvsMat3 * pos + glyphOffset;\n\n  gl_Position = vec4(v_pos.xy, z, 1.0);\n\n  v_tex = a_texAndSize.xy / u_mosaicSize;\n  v_antialiasingWidth = 0.106 * sdfFontSize / fontSize / u_pixelRatio;\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = halo * outlineScale * a_texAndSize.w / fontScale / maxSdfDistance;\n\n#ifdef ID\n  v_fadeStep = u_fadeStep;\n#else\n  v_color = a_color;\n  // Enable this code to visualize hidden glyphs\n  // float a = 1.0;\n  // if (z != 0.0)  {\n  //   a = 0.645;\n  // }\n  // v_color = vec4(a_color.rgb, a);\n#endif // ID\n}\n"},line:{"constants.glsl":"const float thinLineHalfWidth = 1.0; // meaning that a 2 pixels line width is considered a thin line\nconst float thinLineWidthFactor = 1.1;\n","line.frag":"precision lowp float;\n\nuniform lowp float u_blur;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\nuniform mediump float u_zoomFactor;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef SDF\nconst float sdfPatternHalfWidth = 15.5; // YF: assumed that the width will be set to 31\nconst float widthFactor = 2.0;\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\n#include <materials/line/constants.glsl>\n\nvoid main()\n{\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n  mediump float thinLineFactor = max(thinLineWidthFactor * step(v_lineHalfWidth, thinLineHalfWidth), 1.0);\n\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // when it is a thin line then use a slightly shallower slope in order to add more feathering\n  lowp float alpha = clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\n\n#if defined(SDF)\n  mediump float lineHalfWidth = widthFactor * v_lineHalfWidth;\n  mediump float lineWidthRatio = lineHalfWidth / sdfPatternHalfWidth;\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\n  mediump float relativeTexY = 0.5 + 0.5 * v_normal.y;\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  mediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\n\n  // the distance is a proportional to the line width\n  float dist = d * lineHalfWidth;\n\n  lowp vec4 fillPixelColor = v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n  gl_FragColor = fillPixelColor;\n#elif defined(PATTERN)\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\n\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  gl_FragColor = v_transparency * alpha * v_color * color;\n#else // solid line (no texture, no pattern)\n  // output the fragment color\n  gl_FragColor = v_transparency * alpha * v_color;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\n\nattribute float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n// T: TileCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_dvsMat3;\n// T: ScreenCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3\nuniform highp mat3 u_dvMat3;\n\nuniform mediump float u_zoomFactor;\nuniform mediump float u_antialiasing;\n\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\nconst float scale = 1.0 / 31.0;\n#ifdef SDF\nconst float widthFactor = 2.0;\n#else\nconst float widthFactor = 1.0;\n#endif\n\n\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\n#endif // PATTERN\n\n// we need to accumulated distance only if it is a pattern or an SDF line\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/line/vvUniforms.glsl>\n#include <materials/line/vvFunctions.glsl>\n\n// include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\n#include <materials/line/constants.glsl>\n\nvoid main()\n{\n// size VV block\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  mediump float lineHalfWidth = 0.5 * getVVMinMaxSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\n  mediump float lineHalfWidth = 0.5 * u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\n  mediump float lineHalfWidth = 0.5 * getVVStopsSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\n  mediump float lineHalfWidth = 0.5 * getVVUnitValue(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_UNIT_VALUE\n\n#else // no VV\n  mediump float lineHalfWidth = a_accumulatedDistanceAndHalfWidth.y * scale;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_OPACITY\nv_transparency = getVVOpacity(a_vv.z);\n#else\nv_transparency = 1.0;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nv_color = getVVColor(a_vv.y, a_color);\n#else\nv_color = a_color;\n#endif // VV_COLOR\n\n  // make sure to clip the vertices in case that the width of the line is 0 (or negative),\n  // or in case that the line is not visible\n  float z = 2.0 * (step(lineHalfWidth, 0.0) + (1.0 - a_visible));\n\n  // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\n  // also limit the total line width to 1.3 pixels. Below this value lines don't look good compared\n  // to the SVG renderer\n  lineHalfWidth = max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\n\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides\n  // of the centerline) in practice, a thin line is a line who's half width vary from 0.45px to\n  // the value of thinLineHalfWidth, as the value is claped in line 221 above\n  mediump float thinLineFactor = max(thinLineWidthFactor * step(lineHalfWidth, thinLineHalfWidth), 1.0);\n\n  v_lineHalfWidth = lineHalfWidth;\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is\n  // given in integers (for the sake of using less attribute memory, we need to scale it back to\n  // the original range of ~ [0, 1]) in a case of a thin line we move each vertex twice as far\n  mediump vec2 dist = thinLineFactor * widthFactor * lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n  vec3 offset = u_dvMat3 * vec3(dist, 0.0);\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos.xy, 1.0) + offset;\n\n  gl_Position = vec4(v_pos.xy, z, 1.0);\n\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#if defined(PATTERN) || defined(SDF)\n  v_accumulatedDistance = a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\n#endif // PATTERN || SDF\n\n#ifdef PATTERN\nv_tlbr = vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\nv_patternSize = vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\n#endif // PATTERN\n\n#ifdef ID\nv_id = a_id;\n#endif // ID\n}\n","vvFunctions.glsl":"const highp float nanValue = 1e-30;\n\nbool isNan(float val) {\n  return (val == nanValue);\n  //return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  float f = (sizeValue - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  return clamp(mix(u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w, f), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY)\nattribute highp vec3 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY\n\n#ifdef VV_COLOR\nuniform highp float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float u_vvSizeScaleStopsValue;\n#endif\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform highp float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n"},text:{"text.frag":"precision lowp float;\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n  \n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float alpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"precision mediump float;\n\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\n\nattribute vec2 a_pos;           // 2 * 2 (2 x signed 16)\nattribute vec4 a_id;            // 4 (4 x unsigned byte)\nattribute vec4 a_color;         // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texFontSize; // 4 (4 x unsigned byte) texture coordinatesm and font size\n\nattribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\n// T: TileCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\n// by 16 and then at the shader devide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\nconst float outlineScale = 1.0 / 5.0;\nconst float sdfFontSize = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\n// 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\nconst float maxSdfDistance = 8.0;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/text/vvUniforms.glsl>\n#include <materials/text/vvFunctions.glsl>\n\nvoid main()\n{\n  // make sure to clip the vertices in case that given record is marked as invisible\n  float z = 2.0 * (1.0 - a_visible);\n\n  // we use the list significant bit of the position in order to store the indication whethe the vertex is of a halow of a glyph\n  mediump float halo = mod(a_pos, 2.0).x;\n\n  float fontSize = a_texFontSize.z;\n  float scale = 1.0;\n\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  #ifdef VV_SIZE_MIN_MAX_VALUE\n    // vv size override the original symbol's size\n    vec2 size = vec2(getVVMinMaxSize(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_SCALE_STOPS\n    vec2 size = vec2(u_vvSizeScaleStopsValue);\n  #endif // VV_SIZE_SCALE_STOPS\n\n  #ifdef VV_SIZE_FIELD_STOPS\n    vec2 size = vec2(getVVStopsSize(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n    vec2 size = vec2(getVVUnitValue(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_UNIT_VALUE\n\n    scale = size.x / fontSize;\n    fontSize = size.x;\n\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  float fontScale = fontSize / sdfFontSize;\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n  vec3 offset = vec3(offsetPrecision * a_vertexOffset * scale, 0.0);\n\n#ifdef VV_ROTATION\n  vec3 glyphOffset = u_displayMat3 * getVVRotationMat3(a_vv.w) * offset;\n#else\n  vec3 glyphOffset = u_displayMat3 * offset;\n#endif // VV_ROTATION\n\n  vec3 v_pos = u_dvsMat3 * pos + glyphOffset;\n  gl_Position = vec4(v_pos.xy, z, 1.0);\n\n\n  v_tex = a_texFontSize.xy / u_mosaicSize;\n  v_antialiasingWidth = 0.105 * sdfFontSize / fontSize / u_pixelRatio;\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = halo * outlineScale * a_texFontSize.w / fontScale / maxSdfDistance;\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#else\n  v_transparency = 1.0;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\n  // we don't want to override the halo color\n  v_color = halo * a_color + (1.0 - halo) * getVVColor(a_vv.y, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n}\n","vvFunctions.glsl":"const highp float nanValue = 1e-30;\n\nbool isNan(float val) {\n  return (val == nanValue);\n  //return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  return clamp(u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n\nmat3 getVVRotationMat3(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat3(1, 0, 0,\n                0, 1, 0,\n                0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * -rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat3(cosA, -sinA, 0,\n             sinA, cosA, 0,\n              0,    0,    1);\n}\n\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\nattribute highp vec4 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\n\n#ifdef VV_COLOR\nuniform highp float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform highp float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n"}},raster:{"solid.frag":"precision mediump float;\n\nvoid main(void) {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n","texture.frag":"precision mediump float;\n\n// Texture coordinates.\nvarying vec2 v_texcoord;\n\n// Texture sampler.\nuniform sampler2D u_texture;\n\n// Opacity.\nuniform float u_opacity;\n\nvoid main(void) {\n  vec4 color = texture2D(u_texture, v_texcoord);\n  color.a *= u_opacity;\n  gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n","transform.vert":'precision mediump float;\n\n// Vertex position. Assumed normalized in the [-1, 1] range.\nattribute vec2 a_position;\n\n// Texture coordinates. Assumed normalized in the [-1, 1] range.\nattribute vec2 a_texcoord;\n\n// Transform matrix.\nuniform mat4 u_transform;\n\n// Scales applied to position and texture coordinates to get the\n// "unnormalized" value.\nuniform float u_positionScale;\nuniform float u_texcoordScale;\n\n// Output texture coordinates, for interpolation.\nvarying vec2 v_texcoord;\n\nvoid main(void) {\n  gl_Position = u_transform * vec4(a_position * u_positionScale, 0.0, 1.0);\n  v_texcoord = a_texcoord * u_texcoordScale;\n}\n'},stencil:{"stencil.frag":"void main() {\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n","stencil.vert":"attribute vec2 a_pos;\n\nvoid main() {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\n\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  vec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\n  \n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}});