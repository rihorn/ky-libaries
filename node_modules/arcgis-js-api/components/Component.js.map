{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./node_modules/maquette/dist/maquette.umd.js","webpack:///./src/_utils/functional/higherOrderFunctions/compose.ts","webpack:///./src/_utils/functional/primitives/object.ts","webpack:///./src/Component.ts","webpack:///./src/_utils/functional/higherOrderFunctions/curry.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","__extends","__assign","extendStatics","b","setPrototypeOf","__proto__","Array","__","this","constructor","assign","arguments","length","apply","updateDom","NAMESPACE_SVG","NAMESPACE_W3","emptyArray","extend","base","overrides","result","keys","forEach","same","vnode1","vnode2","vnodeSelector","properties","checkStyleValue","styleValue","Error","findIndexOfChild","children","sameAs","start","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","undefined","node","nodeAdded","vNode","enterAnimation","domNode","removedNodes","requestedIdleCallback","visitRemovedNode","afterRemoved","processPendingNodeRemovals","scheduleNodeRemoval","push","window","requestIdleCallback","timeout","setTimeout","nodeToRemove","exitAnimation","style","pointerEvents","parentNode","removeChild","initPropertiesAndChildren","vnode","projectionOptions","_i","children_1","child","createDom","addChildren","text","textContent","eventHandlerInterceptor","propNames","propCount","_loop_1","propName","propValue","toggleClasses","classNames","classNameCount","j","className","classList","add","styleNames","styleCount","styleName","styleApplyer","type","lastIndexOf","oldPropValue","evt","target","namespace","setAttributeNS","setAttribute","setProperties","afterCreate","insertBefore","doc","ownerDocument","createTextNode","appendChild","charAt","found","slice","id","createElementNS","createElement","classes","on","split","toggle","previous","textUpdated","updated","newTextNode","replaceChild","firstChild","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","oldChild","newChild","findOldIndex","updateChildren","previousProperties","propertiesUpdated","previousValue","previousOn","remove","newStyleValue","oldStyleValue","domValue","removeAttribute","updateProperties","afterUpdate","updateAnimation","find","createProjection","getLastRender","update","updatedVnode","previousVNode","DEFAULT_PROJECTION_OPTIONS","performanceLogger","applyDefaultProjectionOptions","projectorOptions","dom","document","append","beforeNode","merge","element","replace","toTextVNode","data","toString","appendChildren","parentSelector","insertions","main","length_1","item","isArray","items","predicate","filter","createEventHandlerInterceptor","projector","getProjection","modifiedEventHandler","projection","parentNodePath","rootNode","createParentNodePath","currentTarget","reverse","matchingVNode","findVNodeByParentNodePath","scheduleRender","propertyName","eventHandler","h","selector","flattenedChildren","createProjector","scheduled","renderCompleted","stopped","projections","renderFunctions","addProjection","domFunction","renderFunction","doRender","renderNow","requestAnimationFrame","stop","cancelAnimationFrame","resume","detach","splice","createCache","cachedInputs","cachedOutcome","invalidate","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","results","map","newSources","newKeys","oldTargets","source","sourceKey","searchIndex","factory","compose","funcs","arg","reduceRight","composed","f","isEmpty","input","scrubObjectProperty","_higherOrderFunctions_index__WEBPACK_IMPORTED_MODULE_1__","obj","newObj","tslib__WEBPACK_IMPORTED_MODULE_0__","mapObjIndexed","fn","curriedMapObjIndexed","reduce","acc","pickBy","curriedPickBy","store","renderRoot","rc","RootComponent","maquette__WEBPACK_IMPORTED_MODULE_1__","newProjector","render","tsx","subscribe","Component","props","childComponents","state","componentDidConnect","componentWillReceiveProps","nextProps","setState","newState","dispatch","console","warn","ch","isConstructor","el","getState","_super","_this","_a","connect","mapStateToProps","mapDispatchToProps","WrappedComponent","ownProps","hy","applyMiddleware","middlewares","next","reducer","initialState","_utils_index__WEBPACK_IMPORTED_MODULE_2__","chain","middleware","action","shunt","recipient","payload","Function","exec","trim","set","thunk","addListener","listener","combineReducers","reducers","finalReducers","_utils_index__WEBPACK_IMPORTED_MODULE_3__","val","createStore","subscribers","handler","indexOf","Math","random","substring","curry","curried","args","concat","rest"],"mappings":"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","file":"Component.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 249);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.maquette = {})));\n}(this, (function (exports) { 'use strict';\n\n    /* tslint:disable no-http-string */\r\n    var NAMESPACE_W3 = 'http://www.w3.org/';\r\n    /* tslint:enable no-http-string */\r\n    var NAMESPACE_SVG = NAMESPACE_W3 + \"2000/svg\";\r\n    var NAMESPACE_XLINK = NAMESPACE_W3 + \"1999/xlink\";\r\n    var emptyArray = [];\r\n    var extend = function (base, overrides) {\r\n        var result = {};\r\n        Object.keys(base).forEach(function (key) {\r\n            result[key] = base[key];\r\n        });\r\n        if (overrides) {\r\n            Object.keys(overrides).forEach(function (key) {\r\n                result[key] = overrides[key];\r\n            });\r\n        }\r\n        return result;\r\n    };\r\n    var same = function (vnode1, vnode2) {\r\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\r\n            return false;\r\n        }\r\n        if (vnode1.properties && vnode2.properties) {\r\n            if (vnode1.properties.key !== vnode2.properties.key) {\r\n                return false;\r\n            }\r\n            return vnode1.properties.bind === vnode2.properties.bind;\r\n        }\r\n        return !vnode1.properties && !vnode2.properties;\r\n    };\r\n    var checkStyleValue = function (styleValue) {\r\n        if (typeof styleValue !== 'string') {\r\n            throw new Error('Style values must be strings');\r\n        }\r\n    };\r\n    var findIndexOfChild = function (children, sameAs, start) {\r\n        if (sameAs.vnodeSelector !== '') {\r\n            // Never scan for text-nodes\r\n            for (var i = start; i < children.length; i++) {\r\n                if (same(children[i], sameAs)) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\r\n        var childNode = childNodes[indexToCheck];\r\n        if (childNode.vnodeSelector === '') {\r\n            return; // Text nodes need not be distinguishable\r\n        }\r\n        var properties = childNode.properties;\r\n        var key = properties ? (properties.key === undefined ? properties.bind : properties.key) : undefined;\r\n        if (!key) { // A key is just assumed to be unique\r\n            for (var i = 0; i < childNodes.length; i++) {\r\n                if (i !== indexToCheck) {\r\n                    var node = childNodes[i];\r\n                    if (same(node, childNode)) {\r\n                        throw new Error(parentVNode.vnodeSelector + \" had a \" + childNode.vnodeSelector + \" child \" + (operation === 'added' ? operation : 'removed') + \", but there is now more than one. You must add unique key properties to make them distinguishable.\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    var nodeAdded = function (vNode) {\r\n        if (vNode.properties) {\r\n            var enterAnimation = vNode.properties.enterAnimation;\r\n            if (enterAnimation) {\r\n                enterAnimation(vNode.domNode, vNode.properties);\r\n            }\r\n        }\r\n    };\r\n    var removedNodes = [];\r\n    var requestedIdleCallback = false;\r\n    var visitRemovedNode = function (node) {\r\n        (node.children || []).forEach(visitRemovedNode);\r\n        if (node.properties && node.properties.afterRemoved) {\r\n            node.properties.afterRemoved.apply(node.properties.bind || node.properties, [node.domNode]);\r\n        }\r\n    };\r\n    var processPendingNodeRemovals = function () {\r\n        requestedIdleCallback = false;\r\n        removedNodes.forEach(visitRemovedNode);\r\n        removedNodes.length = 0;\r\n    };\r\n    var scheduleNodeRemoval = function (vNode) {\r\n        removedNodes.push(vNode);\r\n        if (!requestedIdleCallback) {\r\n            requestedIdleCallback = true;\r\n            if (typeof window !== 'undefined' && 'requestIdleCallback' in window) {\r\n                window.requestIdleCallback(processPendingNodeRemovals, { timeout: 16 });\r\n            }\r\n            else {\r\n                setTimeout(processPendingNodeRemovals, 16);\r\n            }\r\n        }\r\n    };\r\n    var nodeToRemove = function (vNode) {\r\n        var domNode = vNode.domNode;\r\n        if (vNode.properties) {\r\n            var exitAnimation = vNode.properties.exitAnimation;\r\n            if (exitAnimation) {\r\n                domNode.style.pointerEvents = 'none';\r\n                var removeDomNode = function () {\r\n                    if (domNode.parentNode) {\r\n                        domNode.parentNode.removeChild(domNode);\r\n                        scheduleNodeRemoval(vNode);\r\n                    }\r\n                };\r\n                exitAnimation(domNode, removeDomNode, vNode.properties);\r\n                return;\r\n            }\r\n        }\r\n        if (domNode.parentNode) {\r\n            domNode.parentNode.removeChild(domNode);\r\n            scheduleNodeRemoval(vNode);\r\n        }\r\n    };\r\n    var setProperties = function (domNode, properties, projectionOptions) {\r\n        if (!properties) {\r\n            return;\r\n        }\r\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\r\n        var propNames = Object.keys(properties);\r\n        var propCount = propNames.length;\r\n        var _loop_1 = function (i) {\r\n            var propName = propNames[i];\r\n            var propValue = properties[propName];\r\n            if (propName === 'className') {\r\n                throw new Error('Property \"className\" is not supported, use \"class\".');\r\n            }\r\n            else if (propName === 'class') {\r\n                toggleClasses(domNode, propValue, true);\r\n            }\r\n            else if (propName === 'classes') {\r\n                // object with string keys and boolean values\r\n                var classNames = Object.keys(propValue);\r\n                var classNameCount = classNames.length;\r\n                for (var j = 0; j < classNameCount; j++) {\r\n                    var className = classNames[j];\r\n                    if (propValue[className]) {\r\n                        domNode.classList.add(className);\r\n                    }\r\n                }\r\n            }\r\n            else if (propName === 'styles') {\r\n                // object with string keys and string (!) values\r\n                var styleNames = Object.keys(propValue);\r\n                var styleCount = styleNames.length;\r\n                for (var j = 0; j < styleCount; j++) {\r\n                    var styleName = styleNames[j];\r\n                    var styleValue = propValue[styleName];\r\n                    if (styleValue) {\r\n                        checkStyleValue(styleValue);\r\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\r\n                    }\r\n                }\r\n            }\r\n            else if (propName !== 'key' && propValue !== null && propValue !== undefined) {\r\n                var type = typeof propValue;\r\n                if (type === 'function') {\r\n                    if (propName.lastIndexOf('on', 0) === 0) { // lastIndexOf(,0)===0 -> startsWith\r\n                        if (eventHandlerInterceptor) {\r\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties); // intercept eventhandlers\r\n                        }\r\n                        if (propName === 'oninput') {\r\n                            /* tslint:disable no-this-keyword no-invalid-this only-arrow-functions no-void-expression */\r\n                            (function () {\r\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\r\n                                var oldPropValue = propValue;\r\n                                propValue = function (evt) {\r\n                                    oldPropValue.apply(this, [evt]);\r\n                                    evt.target['oninput-value'] = evt.target.value; // may be HTMLTextAreaElement as well\r\n                                };\r\n                            }());\r\n                            /* tslint:enable */\r\n                        }\r\n                        domNode[propName] = propValue;\r\n                    }\r\n                }\r\n                else if (projectionOptions.namespace === NAMESPACE_SVG) {\r\n                    if (propName === 'href') {\r\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\r\n                    }\r\n                    else {\r\n                        // all SVG attributes are read-only in DOM, so...\r\n                        domNode.setAttribute(propName, propValue);\r\n                    }\r\n                }\r\n                else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\r\n                    domNode.setAttribute(propName, propValue);\r\n                }\r\n                else {\r\n                    domNode[propName] = propValue;\r\n                }\r\n            }\r\n        };\r\n        for (var i = 0; i < propCount; i++) {\r\n            _loop_1(i);\r\n        }\r\n    };\r\n    var addChildren = function (domNode, children, projectionOptions) {\r\n        if (!children) {\r\n            return;\r\n        }\r\n        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\r\n            var child = children_1[_i];\r\n            createDom(child, domNode, undefined, projectionOptions);\r\n        }\r\n    };\r\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\r\n        addChildren(domNode, vnode.children, projectionOptions); // children before properties, needed for value property of <select>.\r\n        if (vnode.text) {\r\n            domNode.textContent = vnode.text;\r\n        }\r\n        setProperties(domNode, vnode.properties, projectionOptions);\r\n        if (vnode.properties && vnode.properties.afterCreate) {\r\n            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\r\n        }\r\n    };\r\n    var createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\r\n        var domNode;\r\n        var start = 0;\r\n        var vnodeSelector = vnode.vnodeSelector;\r\n        var doc = parentNode.ownerDocument;\r\n        if (vnodeSelector === '') {\r\n            domNode = vnode.domNode = doc.createTextNode(vnode.text);\r\n            if (insertBefore !== undefined) {\r\n                parentNode.insertBefore(domNode, insertBefore);\r\n            }\r\n            else {\r\n                parentNode.appendChild(domNode);\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0; i <= vnodeSelector.length; ++i) {\r\n                var c = vnodeSelector.charAt(i);\r\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\r\n                    var type = vnodeSelector.charAt(start - 1);\r\n                    var found = vnodeSelector.slice(start, i);\r\n                    if (type === '.') {\r\n                        domNode.classList.add(found);\r\n                    }\r\n                    else if (type === '#') {\r\n                        domNode.id = found;\r\n                    }\r\n                    else {\r\n                        if (found === 'svg') {\r\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\r\n                        }\r\n                        if (projectionOptions.namespace !== undefined) {\r\n                            domNode = vnode.domNode = doc.createElementNS(projectionOptions.namespace, found);\r\n                        }\r\n                        else {\r\n                            domNode = vnode.domNode = (vnode.domNode || doc.createElement(found));\r\n                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\r\n                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\r\n                                domNode.setAttribute('type', vnode.properties.type);\r\n                            }\r\n                        }\r\n                        if (insertBefore !== undefined) {\r\n                            parentNode.insertBefore(domNode, insertBefore);\r\n                        }\r\n                        else if (domNode.parentNode !== parentNode) {\r\n                            parentNode.appendChild(domNode);\r\n                        }\r\n                    }\r\n                    start = i + 1;\r\n                }\r\n            }\r\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\r\n        }\r\n    };\r\n    var updateDom;\r\n    /**\r\n     * Adds or removes classes from an Element\r\n     * @param domNode the element\r\n     * @param classes a string separated list of classes\r\n     * @param on true means add classes, false means remove\r\n     */\r\n    var toggleClasses = function (domNode, classes, on) {\r\n        if (!classes) {\r\n            return;\r\n        }\r\n        classes.split(' ').forEach(function (c) { return domNode.classList.toggle(c, on); });\r\n    };\r\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\r\n        if (!properties) {\r\n            return;\r\n        }\r\n        var propertiesUpdated = false;\r\n        var propNames = Object.keys(properties);\r\n        var propCount = propNames.length;\r\n        for (var i = 0; i < propCount; i++) {\r\n            var propName = propNames[i];\r\n            // assuming that properties will be nullified instead of missing is by design\r\n            var propValue = properties[propName];\r\n            var previousValue = previousProperties[propName];\r\n            if (propName === 'class') {\r\n                if (previousValue !== propValue) {\r\n                    toggleClasses(domNode, previousValue, false);\r\n                    toggleClasses(domNode, propValue, true);\r\n                }\r\n            }\r\n            else if (propName === 'classes') {\r\n                var classList = domNode.classList;\r\n                var classNames = Object.keys(propValue);\r\n                var classNameCount = classNames.length;\r\n                for (var j = 0; j < classNameCount; j++) {\r\n                    var className = classNames[j];\r\n                    var on = !!propValue[className];\r\n                    var previousOn = !!previousValue[className];\r\n                    if (on === previousOn) {\r\n                        continue;\r\n                    }\r\n                    propertiesUpdated = true;\r\n                    if (on) {\r\n                        classList.add(className);\r\n                    }\r\n                    else {\r\n                        classList.remove(className);\r\n                    }\r\n                }\r\n            }\r\n            else if (propName === 'styles') {\r\n                var styleNames = Object.keys(propValue);\r\n                var styleCount = styleNames.length;\r\n                for (var j = 0; j < styleCount; j++) {\r\n                    var styleName = styleNames[j];\r\n                    var newStyleValue = propValue[styleName];\r\n                    var oldStyleValue = previousValue[styleName];\r\n                    if (newStyleValue === oldStyleValue) {\r\n                        continue;\r\n                    }\r\n                    propertiesUpdated = true;\r\n                    if (newStyleValue) {\r\n                        checkStyleValue(newStyleValue);\r\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\r\n                    }\r\n                    else {\r\n                        projectionOptions.styleApplyer(domNode, styleName, '');\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (!propValue && typeof previousValue === 'string') {\r\n                    propValue = '';\r\n                }\r\n                if (propName === 'value') { // value can be manipulated by the user directly and using event.preventDefault() is not an option\r\n                    var domValue = domNode[propName];\r\n                    if (domValue !== propValue // The 'value' in the DOM tree !== newValue\r\n                        && (domNode['oninput-value']\r\n                            ? domValue === domNode['oninput-value'] // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput\r\n                            : propValue !== previousValue // Only update the value if the vdom changed\r\n                        )) {\r\n                        // The edge cases are described in the tests\r\n                        domNode[propName] = propValue; // Reset the value, even if the virtual DOM did not change\r\n                        domNode['oninput-value'] = undefined;\r\n                    } // else do not update the domNode, otherwise the cursor position would be changed\r\n                    if (propValue !== previousValue) {\r\n                        propertiesUpdated = true;\r\n                    }\r\n                }\r\n                else if (propValue !== previousValue) {\r\n                    var type = typeof propValue;\r\n                    if (type !== 'function' || !projectionOptions.eventHandlerInterceptor) { // Function updates are expected to be handled by the EventHandlerInterceptor\r\n                        if (projectionOptions.namespace === NAMESPACE_SVG) {\r\n                            if (propName === 'href') {\r\n                                domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\r\n                            }\r\n                            else {\r\n                                // all SVG attributes are read-only in DOM, so...\r\n                                domNode.setAttribute(propName, propValue);\r\n                            }\r\n                        }\r\n                        else if (type === 'string' && propName !== 'innerHTML') {\r\n                            if (propName === 'role' && propValue === '') {\r\n                                domNode.removeAttribute(propName);\r\n                            }\r\n                            else {\r\n                                domNode.setAttribute(propName, propValue);\r\n                            }\r\n                        }\r\n                        else if (domNode[propName] !== propValue) { // Comparison is here for side-effects in Edge with scrollLeft and scrollTop\r\n                            domNode[propName] = propValue;\r\n                        }\r\n                        propertiesUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return propertiesUpdated;\r\n    };\r\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\r\n        if (oldChildren === newChildren) {\r\n            return false;\r\n        }\r\n        oldChildren = oldChildren || emptyArray;\r\n        newChildren = newChildren || emptyArray;\r\n        var oldChildrenLength = oldChildren.length;\r\n        var newChildrenLength = newChildren.length;\r\n        var oldIndex = 0;\r\n        var newIndex = 0;\r\n        var i;\r\n        var textUpdated = false;\r\n        while (newIndex < newChildrenLength) {\r\n            var oldChild = (oldIndex < oldChildrenLength) ? oldChildren[oldIndex] : undefined;\r\n            var newChild = newChildren[newIndex];\r\n            if (oldChild !== undefined && same(oldChild, newChild)) {\r\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\r\n                oldIndex++;\r\n            }\r\n            else {\r\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\r\n                if (findOldIndex >= 0) {\r\n                    // Remove preceding missing children\r\n                    for (i = oldIndex; i < findOldIndex; i++) {\r\n                        nodeToRemove(oldChildren[i]);\r\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\r\n                    }\r\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\r\n                    oldIndex = findOldIndex + 1;\r\n                }\r\n                else {\r\n                    // New child\r\n                    createDom(newChild, domNode, (oldIndex < oldChildrenLength) ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\r\n                    nodeAdded(newChild);\r\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\r\n                }\r\n            }\r\n            newIndex++;\r\n        }\r\n        if (oldChildrenLength > oldIndex) {\r\n            // Remove child fragments\r\n            for (i = oldIndex; i < oldChildrenLength; i++) {\r\n                nodeToRemove(oldChildren[i]);\r\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\r\n            }\r\n        }\r\n        return textUpdated;\r\n    };\r\n    updateDom = function (previous, vnode, projectionOptions) {\r\n        var domNode = previous.domNode;\r\n        var textUpdated = false;\r\n        if (previous === vnode) {\r\n            return false; // By contract, VNode objects may not be modified anymore after passing them to maquette\r\n        }\r\n        var updated = false;\r\n        if (vnode.vnodeSelector === '') {\r\n            if (vnode.text !== previous.text) {\r\n                var newTextNode = domNode.ownerDocument.createTextNode(vnode.text);\r\n                domNode.parentNode.replaceChild(newTextNode, domNode);\r\n                vnode.domNode = newTextNode;\r\n                textUpdated = true;\r\n                return textUpdated;\r\n            }\r\n            vnode.domNode = domNode;\r\n        }\r\n        else {\r\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) { // lastIndexOf(needle,0)===0 means StartsWith\r\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\r\n            }\r\n            if (previous.text !== vnode.text) {\r\n                updated = true;\r\n                if (vnode.text === undefined) {\r\n                    domNode.removeChild(domNode.firstChild); // the only textnode presumably\r\n                }\r\n                else {\r\n                    domNode.textContent = vnode.text;\r\n                }\r\n            }\r\n            vnode.domNode = domNode;\r\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\r\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\r\n            if (vnode.properties && vnode.properties.afterUpdate) {\r\n                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [domNode, projectionOptions, vnode.vnodeSelector, vnode.properties, vnode.children]);\r\n            }\r\n        }\r\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\r\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\r\n        }\r\n        return textUpdated;\r\n    };\r\n    var createProjection = function (vnode, projectionOptions) {\r\n        return {\r\n            getLastRender: function () { return vnode; },\r\n            update: function (updatedVnode) {\r\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\r\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\r\n                }\r\n                var previousVNode = vnode;\r\n                vnode = updatedVnode;\r\n                updateDom(previousVNode, updatedVnode, projectionOptions);\r\n            },\r\n            domNode: vnode.domNode\r\n        };\r\n    };\n\n    var DEFAULT_PROJECTION_OPTIONS = {\r\n        namespace: undefined,\r\n        performanceLogger: function () { return undefined; },\r\n        eventHandlerInterceptor: undefined,\r\n        styleApplyer: function (domNode, styleName, value) {\r\n            // Provides a hook to add vendor prefixes for browsers that still need it.\r\n            domNode.style[styleName] = value;\r\n        }\r\n    };\r\n    var applyDefaultProjectionOptions = function (projectorOptions) {\r\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\r\n    };\r\n    var dom = {\r\n        /**\r\n         * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\r\n         * its [[Projection.domNode|domNode]] property.\r\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\r\n         * objects may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the projection.\r\n         * @returns The [[Projection]] which also contains the DOM Node that was created.\r\n         */\r\n        create: function (vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\r\n            return createProjection(vnode, projectionOptions);\r\n        },\r\n        /**\r\n         * Appends a new child node to the DOM which is generated from a [[VNode]].\r\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\r\n         * @param parentNode - The parent node for the new child node.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\r\n         * objects may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the [[Projection]].\r\n         * @returns The [[Projection]] that was created.\r\n         */\r\n        append: function (parentNode, vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            createDom(vnode, parentNode, undefined, projectionOptions);\r\n            return createProjection(vnode, projectionOptions);\r\n        },\r\n        /**\r\n         * Inserts a new DOM node which is generated from a [[VNode]].\r\n         * This is a low-level method. Users wil typically use a [[Projector]] instead.\r\n         * @param beforeNode - The node that the DOM Node is inserted before.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\r\n         * NOTE: [[VNode]] objects may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\r\n         * @returns The [[Projection]] that was created.\r\n         */\r\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\r\n            return createProjection(vnode, projectionOptions);\r\n        },\r\n        /**\r\n         * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\r\n         * This means that the virtual DOM and the real DOM will have one overlapping element.\r\n         * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\r\n         * This is a low-level method. Users wil typically use a [[Projector]] instead.\r\n         * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\r\n         * may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\r\n         * @returns The [[Projection]] that was created.\r\n         */\r\n        merge: function (element, vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            vnode.domNode = element;\r\n            initPropertiesAndChildren(element, vnode, projectionOptions);\r\n            return createProjection(vnode, projectionOptions);\r\n        },\r\n        /**\r\n         * Replaces an existing DOM node with a node generated from a [[VNode]].\r\n         * This is a low-level method. Users will typically use a [[Projector]] instead.\r\n         * @param element - The node for the [[VNode]] to replace.\r\n         * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\r\n         * objects may only be rendered once.\r\n         * @param projectionOptions - Options to be used to create and update the [[Projection]].\r\n         * @returns The [[Projection]] that was created.\r\n         */\r\n        replace: function (element, vnode, projectionOptions) {\r\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\r\n            createDom(vnode, element.parentNode, element, projectionOptions);\r\n            element.parentNode.removeChild(element);\r\n            return createProjection(vnode, projectionOptions);\r\n        }\r\n    };\n\n    /* tslint:disable function-name */\r\n    var toTextVNode = function (data) {\r\n        return {\r\n            vnodeSelector: '',\r\n            properties: undefined,\r\n            children: undefined,\r\n            text: data.toString(),\r\n            domNode: null\r\n        };\r\n    };\r\n    var appendChildren = function (parentSelector, insertions, main) {\r\n        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\r\n            var item = insertions[i];\r\n            if (Array.isArray(item)) {\r\n                appendChildren(parentSelector, item, main);\r\n            }\r\n            else {\r\n                if (item !== null && item !== undefined && item !== false) {\r\n                    if (typeof item === 'string') {\r\n                        item = toTextVNode(item);\r\n                    }\r\n                    main.push(item);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    function h(selector, properties, children) {\r\n        if (Array.isArray(properties)) {\r\n            children = properties;\r\n            properties = undefined;\r\n        }\r\n        else if ((properties && (typeof properties === 'string' || properties.hasOwnProperty('vnodeSelector'))) ||\r\n            (children && (typeof children === 'string' || children.hasOwnProperty('vnodeSelector')))) {\r\n            throw new Error('h called with invalid arguments');\r\n        }\r\n        var text;\r\n        var flattenedChildren;\r\n        // Recognize a common special case where there is only a single text node\r\n        if (children !== undefined && children.length === 1 && typeof children[0] === 'string') {\r\n            text = children[0];\r\n        }\r\n        else if (children) {\r\n            flattenedChildren = [];\r\n            appendChildren(selector, children, flattenedChildren);\r\n            if (flattenedChildren.length === 0) {\r\n                flattenedChildren = undefined;\r\n            }\r\n        }\r\n        return {\r\n            vnodeSelector: selector,\r\n            properties: properties,\r\n            children: flattenedChildren,\r\n            text: (text === '') ? undefined : text,\r\n            domNode: null\r\n        };\r\n    }\n\n    var createParentNodePath = function (node, rootNode) {\r\n        var parentNodePath = [];\r\n        while (node !== rootNode) {\r\n            parentNodePath.push(node);\r\n            node = node.parentNode;\r\n        }\r\n        return parentNodePath;\r\n    };\r\n    var find;\r\n    if (Array.prototype.find) {\r\n        find = function (items, predicate) { return items.find(predicate); };\r\n    }\r\n    else {\r\n        find = function (items, predicate) { return items.filter(predicate)[0]; };\r\n    }\r\n    var findVNodeByParentNodePath = function (vnode, parentNodePath) {\r\n        var result = vnode;\r\n        parentNodePath.forEach(function (node) {\r\n            result = (result && result.children) ? find(result.children, function (child) { return child.domNode === node; }) : undefined;\r\n        });\r\n        return result;\r\n    };\r\n    var createEventHandlerInterceptor = function (projector, getProjection, performanceLogger) {\r\n        var modifiedEventHandler = function (evt) {\r\n            performanceLogger('domEvent', evt);\r\n            var projection = getProjection();\r\n            var parentNodePath = createParentNodePath(evt.currentTarget, projection.domNode);\r\n            parentNodePath.reverse();\r\n            var matchingVNode = findVNodeByParentNodePath(projection.getLastRender(), parentNodePath);\r\n            projector.scheduleRender();\r\n            var result;\r\n            if (matchingVNode) {\r\n                /* tslint:disable no-invalid-this */\r\n                result = matchingVNode.properties[\"on\" + evt.type].apply(matchingVNode.properties.bind || this, arguments);\r\n                /* tslint:enable no-invalid-this */\r\n            }\r\n            performanceLogger('domEventProcessed', evt);\r\n            return result;\r\n        };\r\n        return function (propertyName, eventHandler, domNode, properties) { return modifiedEventHandler; };\r\n    };\r\n    /**\r\n     * Creates a [[Projector]] instance using the provided projectionOptions.\r\n     *\r\n     * For more information, see [[Projector]].\r\n     *\r\n     * @param projectorOptions   Options that influence how the DOM is rendered and updated.\r\n     */\r\n    var createProjector = function (projectorOptions) {\r\n        var projector;\r\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\r\n        var performanceLogger = projectionOptions.performanceLogger;\r\n        var renderCompleted = true;\r\n        var scheduled;\r\n        var stopped = false;\r\n        var projections = [];\r\n        var renderFunctions = []; // matches the projections array\r\n        var addProjection = function (\r\n        /* one of: dom.append, dom.insertBefore, dom.replace, dom.merge */\r\n        domFunction, \r\n        /* the parameter of the domFunction */\r\n        node, renderFunction) {\r\n            var projection;\r\n            var getProjection = function () { return projection; };\r\n            projectionOptions.eventHandlerInterceptor = createEventHandlerInterceptor(projector, getProjection, performanceLogger);\r\n            projection = domFunction(node, renderFunction(), projectionOptions);\r\n            projections.push(projection);\r\n            renderFunctions.push(renderFunction);\r\n        };\r\n        var doRender = function () {\r\n            scheduled = undefined;\r\n            if (!renderCompleted) {\r\n                return; // The last render threw an error, it should have been logged in the browser console.\r\n            }\r\n            renderCompleted = false;\r\n            performanceLogger('renderStart', undefined);\r\n            for (var i = 0; i < projections.length; i++) {\r\n                var updatedVnode = renderFunctions[i]();\r\n                performanceLogger('rendered', undefined);\r\n                projections[i].update(updatedVnode);\r\n                performanceLogger('patched', undefined);\r\n            }\r\n            performanceLogger('renderDone', undefined);\r\n            renderCompleted = true;\r\n        };\r\n        projector = {\r\n            renderNow: doRender,\r\n            scheduleRender: function () {\r\n                if (!scheduled && !stopped) {\r\n                    scheduled = requestAnimationFrame(doRender);\r\n                }\r\n            },\r\n            stop: function () {\r\n                if (scheduled) {\r\n                    cancelAnimationFrame(scheduled);\r\n                    scheduled = undefined;\r\n                }\r\n                stopped = true;\r\n            },\r\n            resume: function () {\r\n                stopped = false;\r\n                renderCompleted = true;\r\n                projector.scheduleRender();\r\n            },\r\n            append: function (parentNode, renderFunction) {\r\n                addProjection(dom.append, parentNode, renderFunction);\r\n            },\r\n            insertBefore: function (beforeNode, renderFunction) {\r\n                addProjection(dom.insertBefore, beforeNode, renderFunction);\r\n            },\r\n            merge: function (domNode, renderFunction) {\r\n                addProjection(dom.merge, domNode, renderFunction);\r\n            },\r\n            replace: function (domNode, renderFunction) {\r\n                addProjection(dom.replace, domNode, renderFunction);\r\n            },\r\n            detach: function (renderFunction) {\r\n                for (var i = 0; i < renderFunctions.length; i++) {\r\n                    if (renderFunctions[i] === renderFunction) {\r\n                        renderFunctions.splice(i, 1);\r\n                        return projections.splice(i, 1)[0];\r\n                    }\r\n                }\r\n                throw new Error('renderFunction was not found');\r\n            }\r\n        };\r\n        return projector;\r\n    };\n\n    /**\r\n     * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\r\n     * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\r\n     * For more information, see [[CalculationCache]].\r\n     *\r\n     * @param <Result> The type of the value that is cached.\r\n     */\r\n    var createCache = function () {\r\n        var cachedInputs;\r\n        var cachedOutcome;\r\n        return {\r\n            invalidate: function () {\r\n                cachedOutcome = undefined;\r\n                cachedInputs = undefined;\r\n            },\r\n            result: function (inputs, calculation) {\r\n                if (cachedInputs) {\r\n                    for (var i = 0; i < inputs.length; i++) {\r\n                        if (cachedInputs[i] !== inputs[i]) {\r\n                            cachedOutcome = undefined;\r\n                        }\r\n                    }\r\n                }\r\n                if (!cachedOutcome) {\r\n                    cachedOutcome = calculation();\r\n                    cachedInputs = inputs;\r\n                }\r\n                return cachedOutcome;\r\n            }\r\n        };\r\n    };\n\n    /**\r\n     * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\r\n     * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\r\n     *\r\n     * @param <Source>       The type of source items. A database-record for instance.\r\n     * @param <Target>       The type of target items. A [[MaquetteComponent]] for instance.\r\n     * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\r\n     * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\r\n     *                       to the `callback` argument in `Array.map(callback)`.\r\n     * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\r\n     */\r\n    var createMapping = function (getSourceKey, createResult, updateResult) {\r\n        var keys = [];\r\n        var results = [];\r\n        return {\r\n            results: results,\r\n            map: function (newSources) {\r\n                var newKeys = newSources.map(getSourceKey);\r\n                var oldTargets = results.slice();\r\n                var oldIndex = 0;\r\n                for (var i = 0; i < newSources.length; i++) {\r\n                    var source = newSources[i];\r\n                    var sourceKey = newKeys[i];\r\n                    if (sourceKey === keys[oldIndex]) {\r\n                        results[i] = oldTargets[oldIndex];\r\n                        updateResult(source, oldTargets[oldIndex], i);\r\n                        oldIndex++;\r\n                    }\r\n                    else {\r\n                        var found = false;\r\n                        for (var j = 1; j < keys.length + 1; j++) {\r\n                            var searchIndex = (oldIndex + j) % keys.length;\r\n                            if (keys[searchIndex] === sourceKey) {\r\n                                results[i] = oldTargets[searchIndex];\r\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\r\n                                oldIndex = searchIndex + 1;\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            results[i] = createResult(source, i);\r\n                        }\r\n                    }\r\n                }\r\n                results.length = newSources.length;\r\n                keys = newKeys;\r\n            }\r\n        };\r\n    };\n\n    exports.dom = dom;\n    exports.h = h;\n    exports.createProjector = createProjector;\n    exports.createCache = createCache;\n    exports.createMapping = createMapping;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","/**\r\n * Yields a new function which is the composition of input functions\r\n * @param fn0 - function in the pipeline\r\n */\r\nexport function compose<V0, T1>(\r\n    fn0: (x0: V0) => T1\r\n): (x0: V0) => T1;\r\nexport function compose<V0, V1, T1>(\r\n    fn0: (x0: V0, x1: V1) => T1\r\n): (x0: V0, x1: V1) => T1;\r\nexport function compose<V0, V1, V2, T1>(\r\n    fn0: (x0: V0, x1: V1, x2: V2) => T1\r\n): (x0: V0, x1: V1, x2: V2) => T1;\r\nexport function compose<V0, T1, T2>(\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0) => T1\r\n): (x0: V0) => T2;\r\nexport function compose<V0, V1, T1, T2>(\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1) => T1\r\n): (x0: V0, x1: V1) => T2;\r\nexport function compose<V0, V1, V2, T1, T2>(\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1, x2: V2) => T1\r\n): (x0: V0, x1: V1, x2: V2) => T2;\r\nexport function compose<V0, T1, T2, T3>(\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x: V0) => T1\r\n): (x: V0) => T3;\r\nexport function compose<V0, V1, T1, T2, T3>(\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1) => T1\r\n): (x0: V0, x1: V1) => T3;\r\nexport function compose<V0, V1, V2, T1, T2, T3>(\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1, x2: V2) => T1\r\n): (x0: V0, x1: V1, x2: V2) => T3;\r\nexport function compose<V0, T1, T2, T3, T4>(\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x: V0) => T1\r\n): (x: V0) => T4;\r\nexport function compose<V0, V1, T1, T2, T3, T4>(\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1) => T1\r\n): (x0: V0, x1: V1) => T4;\r\nexport function compose<V0, V1, V2, T1, T2, T3, T4>(\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1, x2: V2) => T1\r\n): (x0: V0, x1: V1, x2: V2) => T4;\r\nexport function compose<V0, T1, T2, T3, T4, T5>(\r\n    fn4: (x: T4) => T5,\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x: V0) => T1\r\n): (x: V0) => T5;\r\nexport function compose<V0, V1, T1, T2, T3, T4, T5>(\r\n    fn4: (x: T4) => T5,\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1) => T1\r\n): (x0: V0, x1: V1) => T5;\r\nexport function compose<V0, V1, V2, T1, T2, T3, T4, T5>(\r\n    fn4: (x: T4) => T5,\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1, x2: V2) => T1\r\n): (x0: V0, x1: V1, x2: V2) => T5;\r\nexport function compose<V0, T1, T2, T3, T4, T5, T6>(\r\n    fn5: (x: T5) => T6,\r\n    fn4: (x: T4) => T5,\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x: V0) => T1\r\n): (x: V0) => T6;\r\nexport function compose<V0, V1, T1, T2, T3, T4, T5, T6>(\r\n    fn5: (x: T5) => T6,\r\n    fn4: (x: T4) => T5,\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1) => T1\r\n): (x0: V0, x1: V1) => T6;\r\nexport function compose<V0, V1, V2, T1, T2, T3, T4, T5, T6>(\r\n    fn5: (x: T5) => T6,\r\n    fn4: (x: T4) => T5,\r\n    fn3: (x: T3) => T4,\r\n    fn2: (x: T2) => T3,\r\n    fn1: (x: T1) => T2,\r\n    fn0: (x0: V0, x1: V1, x2: V2) => T1\r\n): (x0: V0, x1: V1, x2: V2) => T6;\r\nexport function compose(...funcs: ((...args: any[]) => any)[]) {\r\n    return (arg: any) => funcs.reduceRight((composed, f) => f(composed), arg);\r\n}\r\n","import { curry } from \"../higherOrderFunctions/index\";\r\n\r\n/**\r\n * Returns true if the object in question is empty\r\n * @param input - object to determine if empty\r\n */\r\nexport function isEmpty(input: object) {\r\n    return Object.keys(input).length === 0 && input.constructor === Object;\r\n}\r\n\r\n/**\r\n * (Curried, arity 2) Returns a shallow clone of an object with a property deleted\r\n * 1. name of the property to scrub\r\n * 2. object to scrub the property from\r\n */\r\nexport const scrubObjectProperty = curry((propertyName: string, obj: { [propName: string]: any }) => {\r\n    const newObj = { ...obj };\r\n    delete newObj[propertyName];\r\n    return newObj;\r\n});\r\n\r\n/**\r\n * CURRIED: Takes a predicate function and an object, and returns the result of\r\n * applying the predicate to each of the object's properties as an object of the same shape.\r\n * @param fn - Predicate function to apply to each property\r\n * @param obj - Object to map\r\n */\r\nexport function mapObjIndexed<T, TResult>(\r\n    fn: (value: T, key: string, obj?: { [key: string]: T }) => TResult,\r\n    obj: { [key: string]: T }\r\n): { [key: string]: TResult };\r\nexport function mapObjIndexed<T, TResult>(\r\n    fn: (value: T, key: string, obj?: { [key: string]: T }) => TResult\r\n): (obj: { [key: string]: T }) => { [key: string]: TResult };\r\nexport function mapObjIndexed(fn: any, obj?: any) {\r\n    return curriedMapObjIndexed.apply(null, arguments);\r\n}\r\nconst curriedMapObjIndexed = curry(<T, TResult>(\r\n    fn: (value: T, key: string, obj?: { [key: string]: T }) => TResult,\r\n    obj: { [key: string]: T }\r\n): { [key: string]: TResult } => (\r\n    Object.keys(obj).reduce(\r\n        (acc: T, key: string) => {\r\n            acc[key] = fn(obj[key], key, obj);\r\n            return acc;\r\n        },\r\n        {}\r\n    )\r\n));\r\n\r\n/**\r\n * CURRIED: Takes a predicate function and an object, and returns a partial copy of that object\r\n * containing only the properties which satisfy the provided predicate.\r\n * @param fn - Predicate function to test each property of the object\r\n * @param obj - Object to pick properties from\r\n */\r\nexport function pickBy<T, U>(fn: (value: any, key: string, obj?: T) => boolean): (obj: T) => U;\r\nexport function pickBy<T, U>(fn: (value: any, key: string, obj?: T) => boolean, obj?: T): U;\r\nexport function pickBy(fn: any, obj?: any): any {\r\n    return curriedPickBy.apply(null, arguments);\r\n}\r\nconst curriedPickBy = curry(<T, U>(fn: (value: any, key: string, obj?: T) => boolean, obj: T): U => (\r\n    Object.keys(obj).reduce(\r\n        (acc: U, key: string) => {\r\n            if (fn(obj[key], key, obj)) {\r\n                acc[key] = obj[key];\r\n            }\r\n            return acc;\r\n        },\r\n        {} as U\r\n    )\r\n));\r\n","import { createProjector as originalCreateProjector, h, ProjectionOptions, Projector as OriginalProjector } from \"maquette\";\r\nimport { compose, pickBy, mapObjIndexed } from \"./_utils/index\";\r\n\r\n/**\r\n * Plain Ol' JavaScript Object\r\n */\r\nexport interface Pojo {\r\n    [propName: string]: any;\r\n}\r\n\r\n////////////////////////////\r\n//\r\n// VIRTUAL DOM & COMPONENTS\r\n//\r\n////////////////////////////\r\n\r\n/**\r\n * Base props for components\r\n */\r\nexport interface ComponentProps {\r\n    key: string;\r\n    children?: JSX.Element[];\r\n}\r\n\r\n/**\r\n * Base props for stateless functional components\r\n */\r\nexport interface SFCProps {\r\n    [propName: string]: any;\r\n    children?: JSX.Element[];\r\n}\r\n\r\nexport interface ComponentConstructor {\r\n    new(props: any): Component<any>;\r\n}\r\n\r\nexport type SFC = (props: SFCProps, tsx: H) => JSX.Element[] | JSX.Element | void;\r\nexport interface Projector extends OriginalProjector {\r\n    append: (node: Element) => void;\r\n}\r\n\r\n/**\r\n * Creates a Projector instance, which projects the VDOM tree to a specified DOM node\r\n * @param store - The big atom state store for the component tree\r\n * @param renderRoot - The root render function for the tree of VDOM\r\n * @param node - The DOM node to render the VDOM into\r\n * @param projectorOptions -  Options that influence how the DOM is rendered and updated\r\n */\r\nexport function createProjector(\r\n    store: Store<any>,\r\n    renderRoot: (tsx: H) => JSX.Element | void,\r\n    node: Element,\r\n    projectorOptions?: ProjectionOptions\r\n) {\r\n    const rc = new RootComponent({ key: \"root\" }, renderRoot);\r\n    rc[\"store\"] = store;\r\n    const projector = originalCreateProjector(projectorOptions);\r\n    const newProjector = {\r\n        ...projector,\r\n        /**\r\n         * Appends the projector to a specified DOM node.\r\n         * @param node - The root DOM element to render the virtual DOM tree into.\r\n         */\r\n        append: (node: Element) => projector.append(\r\n            node,\r\n            () => rc.render.bind(rc)(rc.tsx.bind(rc))\r\n        )\r\n    };\r\n    newProjector.append(node);\r\n    store.subscribe(() => projector.scheduleRender());\r\n    return newProjector;\r\n}\r\n\r\n/**\r\n * Returns a virtual DOM representation of the target component or element.\r\n * @param element - The component of element to create VDOM for.\r\n * @param properties - HTML attributes or component props to provide to the element.\r\n * @param children - Child components or elements to render within this child.\r\n */\r\nexport type H = (\r\n    element: ComponentConstructor | SFC | string,\r\n    properties?: ComponentProps | SFCProps | JSX.ElementAttributesProperty,\r\n    children?: (ComponentConstructor | SFC | string)[]\r\n) => JSX.Element | void;\r\n\r\nexport type RenderCTX = (dispatch?: Store<any>[\"dispatch\"], getState?: Store<any>[\"getState\"]) =>\r\n    JSX.Element | void;\r\n\r\n/**\r\n * A component which returns virtual DOM from its render method.\r\n */\r\nexport abstract class Component<\r\n    Props extends ComponentProps,\r\n    State extends Pojo = {}\r\n> {\r\n    /**\r\n     * Array of child components rendered by this component.\r\n     */\r\n    public childComponents: {\r\n        [key: string]: Component<ComponentProps>;\r\n    } = {};\r\n    /**\r\n     * A component's props are passed into it by its parent component prior to rendering.\r\n     * Props should be assumed to always reflect the current state of the application.\r\n     */\r\n    public props: Props;\r\n    /**\r\n     * A component can maintain its own class-level state, which can be passed down to\r\n     * child components through props. \r\n     */\r\n    protected state: State = {} as State;\r\n    /**\r\n     * The store for the current scope. \r\n     */\r\n    private store: Store<any>;\r\n    constructor(props: Props) {\r\n        this.props = props;\r\n    }\r\n\r\n    /**\r\n     * The component's render function returns virtual DOM as a function of application state.\r\n     * It is used to create the virtual DOM tree representing the application's view.\r\n     */\r\n    abstract render(tsx: H): JSX.Element[] | JSX.Element | void | RenderCTX;\r\n\r\n    /**\r\n     * Lifecycle method called when a component is successfully connected to its parent's store. \r\n     */\r\n    public componentDidConnect() {}\r\n\r\n    /**\r\n     * Lifecycle method called prior to the component's props updating.\r\n     */\r\n    public componentWillReceiveProps(nextProps: Props) {}\r\n\r\n    /**\r\n     * Update's the component's class level state.\r\n     * @param newState - Shallow partial clone of the component's state.\r\n     */\r\n    protected setState(newState: Partial<State>) {\r\n        this.state = { ...this.state as any, ...newState as any };\r\n        if (this.store) {\r\n            this.store.dispatch({ type: `${this.props.key}_COMPONENT_STATE_UPDATE` });\r\n        } else {\r\n            console.warn(`\r\n                A component's 'setState' method was called from its constructor function.\r\n                Set component state directly in the constructor function, and use 'setState' in callbacks etc.\r\n            `);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a virtual DOM representation of the target component or element.\r\n     * @param element - The component of element to create VDOM for.\r\n     * @param properties - HTML attributes or component props to provide to the element.\r\n     * @param children - Child components or elements to render within this child.\r\n     */\r\n    public tsx(\r\n        element: ComponentConstructor | SFC | string,\r\n        properties?: ComponentProps | SFCProps | JSX.ElementAttributesProperty,\r\n        children?: (ComponentConstructor | SFC | string)[]\r\n    ): JSX.Element | void {\r\n        let result;\r\n        const ch = Array.prototype.slice.call(arguments).slice(2); // Force children to be array..\r\n        if (typeof element === \"string\") { // Rendering ordinary hyperscript\r\n            result = h.apply(this, [element, properties, ch]);\r\n        } else if (!isConstructor(element as Function)) { // Rendering a functional component\r\n            const el = element as SFC;\r\n            result = el({ ...properties, children: ch }, this.tsx.bind(this));\r\n        } else { // Rendering a class-based Component\r\n            const el = element as ComponentConstructor;\r\n            const props = { ...properties, children: ch } as ComponentProps;\r\n            let child = this.childComponents[props.key];\r\n            if (child) { // This child has already been instantiated\r\n                child.componentWillReceiveProps(props);\r\n                child.props = (props);\r\n                result = child.render(child.tsx.bind(child));\r\n            } else { // Need to instantiate the component\r\n                child = this.childComponents[props.key] = new el(props);\r\n                child.store = this.store;\r\n                child.componentDidConnect();\r\n                result = child.render(child.tsx.bind(child));\r\n            }\r\n        }\r\n        return typeof result === \"function\" ? result(this.store.dispatch, this.store.getState) : result;\r\n    }\r\n}\r\n\r\n/**\r\n * Root component used as the entrypoint for projector.\r\n * This is necessary to allow store-connected components to be used from the root.\r\n */\r\nexport class RootComponent extends Component<{ key: string }> {\r\n    private renderRoot: (tsx: H) => JSX.Element | void;\r\n    constructor(props: { key: string }, renderRoot: (tsx: H) => JSX.Element | void) {\r\n        super(props);\r\n        this.renderRoot = renderRoot;\r\n    }\r\n\r\n    public render(tsx: H) { return tsx(({}, t: H) => this.renderRoot(t)); }\r\n}\r\n\r\n/**\r\n * Connect provides the ability to map the store's state and dispatch method to a component's props.\r\n * Providing store functionality through connect prevents components from becoming tightly coupled to a store.\r\n * Any props which are not mapped from the store through connect will be exposed from the resulting\r\n * wrapped component unchanged.\r\n * @param mapStateToProps - Function returning props based on the store state\r\n * @param mapDispatchToProps - Function returning props based on the store's dispatch function\r\n * @template WrappedProps - The props for the component being wrapped with connect.\r\n * @template S - The type of store being connected.\r\n * @template StateProps - The props to map to the store state.\r\n * @template DispatchProps - The props to map to the store's dispatch method.\r\n */\r\nexport function connect<\r\n    WrappedProps = {},\r\n    ComponentStore extends Store<any> = Store<any>,\r\n    StateProps = {},\r\n    DispatchProps = {}\r\n>(\r\n    mapStateToProps: (\r\n        state: ReturnType<ComponentStore[\"getState\"]>,\r\n        ownProps: Pick<WrappedProps, Exclude<keyof WrappedProps, keyof StateProps | keyof DispatchProps>>\r\n    ) => StateProps,\r\n    mapDispatchToProps: (\r\n        dispatch: ComponentStore[\"dispatch\"],\r\n        ownProps: Pick<WrappedProps, Exclude<keyof WrappedProps, keyof StateProps | keyof DispatchProps>>\r\n    ) => DispatchProps\r\n) {\r\n    return (WrappedComponent: ComponentConstructor) => (\r\n        ownProps: Pick<WrappedProps, Exclude<keyof WrappedProps, keyof StateProps | keyof DispatchProps>>,\r\n        hy: H\r\n    ) => (\r\n        dispatch: ComponentStore[\"dispatch\"],\r\n        getState: () => ReturnType<ComponentStore[\"getState\"]>\r\n    ) => (\r\n        hy(WrappedComponent, {\r\n            ...ownProps as any,\r\n            ...mapStateToProps(getState(), ownProps) as any,\r\n            ...mapDispatchToProps(dispatch, ownProps) as any\r\n        })\r\n    );\r\n}\r\n\r\n/**\r\n * Returns true if the provided function is a constructor\r\n * @param f - Object to check if constructor\r\n */\r\nfunction isConstructor(f: Function) {\r\n    return !!f.prototype && !!f.prototype.constructor.name;\r\n}\r\n\r\n/**\r\n * Hack in support for Function.name in IE\r\n */\r\nif (Function.prototype[\"name\"] === undefined && Object.defineProperty !== undefined) {\r\n    Object.defineProperty(Function.prototype, \"name\", {\r\n        get: function() {\r\n            var funcNameRegex = /function\\s([^(]{1,})\\(/;\r\n            var results = (funcNameRegex).exec((this).toString());\r\n            return (results && results.length > 1) ? results[1].trim() : \"\";\r\n        },\r\n        set: function(value) {}\r\n    });\r\n}\r\n\r\n////////////////////////////\r\n//\r\n// STATE MANAGEMENT\r\n//\r\n////////////////////////////\r\n\r\nexport type DeepPartial<T> = { [K in keyof T]?: DeepPartial<T[K]> };\r\nexport type Dispatch<A extends Action = Action> = (action: A) => A;\r\nexport type Middleware<DispatchExt = {}, S = any, D extends Dispatch = Dispatch> =\r\n    (api: MiddlewareAPI<D, S>) => (next: Dispatch) => (action: any) => any;\r\nexport type Reducer<S> = (state: S | undefined, action: Action) => S;\r\nexport type StoreCreator<S> = (reducer: Reducer<S>, initialState: S) => Store<S>;\r\nexport type StoreEnhancer<Ext = {}, StateExt = {}> =\r\n    (next: StoreEnhancerStoreCreator) => StoreEnhancerStoreCreator<Ext, StateExt>;\r\nexport type StoreEnhancerStoreCreator<Ext = {}, StateExt = {}> =\r\n    <S = any>(reducer: Reducer<S>, preloadedState?: S) => Store<S & StateExt> & Ext;\r\n\r\nexport interface Action { type: string; payload?: any; }\r\nexport interface MiddlewareAPI<D extends Dispatch = Dispatch, S = any> {\r\n    dispatch: Dispatch;\r\n    getState: () => S;\r\n}\r\nexport interface Store<S> {\r\n    dispatch: Dispatch;\r\n    getState: () => S;\r\n    subscribe: (handler: () => void) => () => void;\r\n}\r\n\r\n/**\r\n * Returns a new store creator with dispatch wrapped by the supplied middleware functions\r\n * @param middlewares - middleware functions\r\n */\r\nexport function applyMiddleware<Ext1, Ext2, Ext3, Ext4, Ext5, S>(\r\n    middleware1: Middleware<Ext1, S, any>,\r\n    middleware2: Middleware<Ext2, S, any>,\r\n    middleware3: Middleware<Ext3, S, any>,\r\n    middleware4: Middleware<Ext4, S, any>,\r\n    middleware5: Middleware<Ext5, S, any>\r\n): StoreEnhancer<{dispatch: Ext1 & Ext2 & Ext3 & Ext4 & Ext5}>;\r\nexport function applyMiddleware<Ext1, Ext2, Ext3, Ext4, S> (\r\n    middleware1: Middleware<Ext1, S, any>,\r\n    middleware2: Middleware<Ext2, S, any>,\r\n    middleware3: Middleware<Ext3, S, any>,\r\n    middleware4: Middleware<Ext4, S, any>\r\n): StoreEnhancer<{dispatch: Ext1 & Ext2 & Ext3 & Ext4}>;\r\nexport function applyMiddleware<Ext1, Ext2, Ext3, S> (\r\n    middleware1: Middleware<Ext1, S, any>,\r\n    middleware2: Middleware<Ext2, S, any>,\r\n    middleware3: Middleware<Ext3, S, any>\r\n): StoreEnhancer<{dispatch: Ext1 & Ext2 & Ext3}>;\r\nexport function applyMiddleware<Ext1, Ext2, S>(\r\n    middleware1: Middleware<Ext1, S, any>,\r\n    middleware2: Middleware<Ext2, S, any>\r\n): StoreEnhancer<{dispatch: Ext1 & Ext2}>;\r\nexport function applyMiddleware<Ext1, S>(middleware1: Middleware<Ext1, S, any>): StoreEnhancer<{dispatch: Ext1}>;\r\nexport function applyMiddleware<Ext, S = any>(\r\n    ...middlewares: Middleware<any, S, any>[]\r\n): StoreEnhancer<{dispatch: Ext}>;\r\nexport function applyMiddleware(...middlewares: Array<Middleware>): StoreEnhancer {\r\n    return (next: StoreEnhancerStoreCreator) => (reducer: Reducer<any>, initialState: any) => {\r\n        const store = next(reducer, initialState);\r\n        const c = compose as any;\r\n        let dispatch = store.dispatch;\r\n\r\n        const chain = middlewares.map((middleware) => middleware({\r\n            dispatch: (action: Action) => dispatch(action),\r\n            getState: store.getState\r\n        }));\r\n        dispatch = c(...chain)(store.dispatch);\r\n\r\n        return { ...store, dispatch };\r\n    };\r\n}\r\n\r\n/**\r\n * Returns a new store creator, which invokes a provided recipient function with the action and new state\r\n * on each dispatch. The store also has a modified reducer which sets the entire state tree equal to the payload\r\n * of the `@@shunt/SETSTATE` action, which allows for imperative updates to the entire state tree.\r\n * The primary use-case for this is to maintain unidirectional data flow between parent and child stores.\r\n * @param recipient - The recipient function which will receive state updates.\r\n * @template S - The type of store to be shunted.\r\n */\r\nexport function shunt<S extends Store<any>>(\r\n    recipient: (action?: ReturnType<S[\"dispatch\"]>, newState?: ReturnType<S[\"getState\"]>) => void\r\n): StoreEnhancer<{}> {\r\n    return (next: StoreEnhancerStoreCreator) => (reducer: any, initialState: ReturnType<S[\"getState\"]>) =>\r\n        next(\r\n            (state: ReturnType<S[\"getState\"]>, action: ReturnType<S[\"dispatch\"]>) => {\r\n                if (action.type === \"@@shunt/SETSTATE\") {\r\n                    return action.payload;\r\n                } else {\r\n                    const newState = reducer(state, action);\r\n                    recipient(action, newState);\r\n                    return newState;\r\n                }\r\n            },\r\n            initialState\r\n        );\r\n}\r\n\r\nexport type ThunkDispatch<S> = (action: Action | ThunkAction<S>) => Action | ThunkAction<S> | void;\r\nexport type ThunkAction<S> = (dispatch?: ThunkDispatch<S>, getState?: () => S) => any\r\n\r\n/**\r\n * Thunk middleware allows for the dispatching of thunks to the store.\r\n * Thunks are passed `dispatch` and `getState` from the store, and can be used to coordinate asynchronous processes.\r\n */\r\nexport const thunk: Middleware = <S>({ dispatch, getState }: MiddlewareAPI) =>\r\n    (next: Dispatch) =>\r\n    (action: Action | ThunkAction<S>) => {\r\n        if (typeof action === \"function\") {\r\n            return action(dispatch, getState);\r\n        }\r\n        return next(action);\r\n    };\r\n\r\n/**\r\n * Listener middleware allows for using the action and resulting state to perform arbitrary side effects.\r\n * @param listener - Listener function to call with action and nextState\r\n */\r\nexport function addListener<S>(listener: (action: Action, nextState: S) => any) {\r\n    return ({ dispatch, getState }: MiddlewareAPI) => (next: Dispatch) => (action: Action) => {\r\n        let result = next(action);\r\n        listener(action, getState());\r\n        return result;\r\n    };\r\n}\r\n\r\n/**\r\n * Composes reducing functions for separate state slices into a single reducing function\r\n * @param reducers - Object mapping keys to the corresponding reducing function for the state slice\r\n */\r\nexport function combineReducers<T>(reducers: { [P in keyof T]: Reducer<T[P]> }) {\r\n    const finalReducers = pickBy<{ [P in keyof T]: Reducer<T[P]> }, { [P in keyof T]: Reducer<T[P]> }>(\r\n        (val) => typeof val === \"function\",\r\n        reducers\r\n    );\r\n    return (state: T = {} as T, action: Action): T => {\r\n        return mapObjIndexed(\r\n            (r: Reducer<T[keyof T]>, key) => r(state[key], action),\r\n            finalReducers\r\n        ) as any as T;\r\n    };\r\n}\r\n\r\n/**\r\n * Returns a big atom state store of shape <T>\r\n * @param reducer - the root reducer for the state tree \r\n * @param initialState - the initial state for the tree\r\n */\r\nexport function createStore<S>(reducer: Reducer<S>, initialState?: S): Store<S> {\r\n    let state = initialState;\r\n    let r = reducer;\r\n    const subscribers: (() => void)[] = [];\r\n    const store = {\r\n        dispatch: (action: Action) => {\r\n            state = r(state, action);\r\n            subscribers.forEach(handler => handler());\r\n            return action;\r\n        },\r\n        subscribe: (handler: () => void) => {\r\n            subscribers.push(handler);\r\n            return function unsubscribe() {\r\n                subscribers.splice(subscribers.indexOf(handler), 1);\r\n            };\r\n        },\r\n        getState() {\r\n            return state;\r\n        }\r\n    };\r\n    store.dispatch({ type: \"@@component/INIT\" + Math.random().toString(36).substring(7) });\r\n    return store as Store<S>;\r\n}\r\n","/**\r\n * Yields a new function which is the curried form of the input function.\r\n * Curried functions can be partially applied with any number of arguments less than their arity to yield\r\n * a new curried function accepting the remaining arguments.\r\n */\r\nexport interface CurriedTypeGuard2<T1, T2, R extends T2> {\r\n    (t1: T1): (t2: T2) => t2 is R;\r\n    (t1: T1, t2: T2): t2 is R;\r\n}\r\nexport interface CurriedTypeGuard3<T1, T2, T3, R extends T3> {\r\n    (t1: T1): CurriedTypeGuard2<T2, T3, R>;\r\n    (t1: T1, t2: T2): (t3: T3) => t3 is R;\r\n    (t1: T1, t2: T2, t3: T3): t3 is R;\r\n}\r\nexport interface CurriedTypeGuard4<T1, T2, T3, T4, R extends T4> {\r\n    (t1: T1): CurriedTypeGuard3<T2, T3, T4, R>;\r\n    (t1: T1, t2: T2): CurriedTypeGuard2<T3, T4, R>;\r\n    (t1: T1, t2: T2, t3: T3): (t4: T4) => t4 is R;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4): t4 is R;\r\n}\r\nexport interface CurriedTypeGuard5<T1, T2, T3, T4, T5, R extends T5> {\r\n    (t1: T1): CurriedTypeGuard4<T2, T3, T4, T5, R>;\r\n    (t1: T1, t2: T2): CurriedTypeGuard3<T3, T4, T5, R>;\r\n    (t1: T1, t2: T2, t3: T3): CurriedTypeGuard2<T4, T5, R>;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4): (t5: T5) => t5 is R;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): t5 is R;\r\n}\r\nexport interface CurriedTypeGuard6<T1, T2, T3, T4, T5, T6, R extends T6> {\r\n    (t1: T1): CurriedTypeGuard5<T2, T3, T4, T5, T6, R>;\r\n    (t1: T1, t2: T2): CurriedTypeGuard4<T3, T4, T5, T6, R>;\r\n    (t1: T1, t2: T2, t3: T3): CurriedTypeGuard3<T4, T5, T6, R>;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4): CurriedTypeGuard2<T5, T6, R>;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): (t6: T6) => t6 is R;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6): t6 is R;\r\n}\r\nexport interface CurriedFunction2<T1, T2, R> {\r\n    (t1: T1): (t2: T2) => R;\r\n    (t1: T1, t2: T2): R;\r\n}\r\nexport interface CurriedFunction3<T1, T2, T3, R> {\r\n    (t1: T1): CurriedFunction2<T2, T3, R>;\r\n    (t1: T1, t2: T2): (t3: T3) => R;\r\n    (t1: T1, t2: T2, t3: T3): R;\r\n}\r\nexport interface CurriedFunction4<T1, T2, T3, T4, R> {\r\n    (t1: T1): CurriedFunction3<T2, T3, T4, R>;\r\n    (t1: T1, t2: T2): CurriedFunction2<T3, T4, R>;\r\n    (t1: T1, t2: T2, t3: T3): (t4: T4) => R;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4): R;\r\n}\r\nexport interface CurriedFunction5<T1, T2, T3, T4, T5, R> {\r\n    (t1: T1): CurriedFunction4<T2, T3, T4, T5, R>;\r\n    (t1: T1, t2: T2): CurriedFunction3<T3, T4, T5, R>;\r\n    (t1: T1, t2: T2, t3: T3): CurriedFunction2<T4, T5, R>;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4): (t5: T5) => R;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\r\n}\r\nexport interface CurriedFunction6<T1, T2, T3, T4, T5, T6, R> {\r\n    (t1: T1): CurriedFunction5<T2, T3, T4, T5, T6, R>;\r\n    (t1: T1, t2: T2): CurriedFunction4<T3, T4, T5, T6, R>;\r\n    (t1: T1, t2: T2, t3: T3): CurriedFunction3<T4, T5, T6, R>;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4): CurriedFunction2<T5, T6, R>;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): (t6: T6) => R;\r\n    (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6): R;\r\n}\r\nexport function curry<T1, T2, TResult extends T2>(\r\n    fn: (a: T1, b: T2) => b is TResult\r\n): CurriedTypeGuard2<T1, T2, TResult>;\r\nexport function curry<T1, T2, T3, TResult extends T3>(\r\n    fn: (a: T1, b: T2, c: T3) => c is TResult\r\n): CurriedTypeGuard3<T1, T2, T3, TResult>;\r\nexport function curry<T1, T2, T3, T4, TResult extends T4>(\r\n    fn: (a: T1, b: T2, c: T3, d: T4) => d is TResult\r\n): CurriedTypeGuard4<T1, T2, T3, T4, TResult>;\r\nexport function curry<T1, T2, T3, T4, T5, TResult extends T5>(\r\n    fn: (a: T1, b: T2, c: T3, d: T4, e: T5) => e is TResult\r\n): CurriedTypeGuard5<T1, T2, T3, T4, T5, TResult>;\r\nexport function curry<T1, T2, T3, T4, T5, T6, TResult extends T6>(\r\n    fn: (a: T1, b: T2, c: T3, d: T4, e: T5, f: T6) => f is TResult\r\n): CurriedTypeGuard6<T1, T2, T3, T4, T5, T6, TResult>;\r\nexport function curry<T1, T2, TResult>(\r\n    fn: (a: T1, b: T2) => TResult\r\n): CurriedFunction2<T1, T2, TResult>;\r\nexport function curry<T1, T2, T3, TResult>(\r\n    fn: (a: T1, b: T2, c: T3) => TResult\r\n): CurriedFunction3<T1, T2, T3, TResult>;\r\nexport function curry<T1, T2, T3, T4, TResult>(\r\n    fn: (a: T1, b: T2, c: T3, d: T4) => TResult\r\n): CurriedFunction4<T1, T2, T3, T4, TResult>;\r\nexport function curry<T1, T2, T3, T4, T5, TResult>(\r\n    fn: (a: T1, b: T2, c: T3, d: T4, e: T5) => TResult\r\n): CurriedFunction5<T1, T2, T3, T4, T5, TResult>;\r\nexport function curry<T1, T2, T3, T4, T5, T6, TResult>(\r\n    fn: (a: T1, b: T2, c: T3, d: T4, e: T5, f: T6) => TResult\r\n): CurriedFunction6<T1, T2, T3, T4, T5, T6, TResult>;\r\nexport function curry(\r\n    fn: (...args: any[]) => any\r\n) {\r\n    return function curried(this: any, ...args: any[]) {\r\n        return args.length >= fn.length ?\r\n            fn.call(this, ...args) :\r\n            (...rest: any[]) => {\r\n                return curried.call(this, ...args, ...rest);\r\n            };\r\n    };\r\n}\r\n"],"sourceRoot":""}